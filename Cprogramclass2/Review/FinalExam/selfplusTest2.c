#include <stdio.h>

int main()
{
    int a = 1;
    int t ;  
    t = a++ + (++a + a ++) ;
    printf("t = a++ + (++a + a ++) = %d\n" , t ) ;

    /**
     * 这个例子蕴含了我对自增加减运算的全部理解
     * 首先，顺序大差不差还是从左到右，括号优先
     * 编译出来的结果表明a++ +(++a + a++)的运算顺序是
     * a++取a值1
     * 然后将a自增至2
     * 再算括号内部表达式
     * 先通过++a将a自增至3
     * 然后将a++取此时a值3
     * 再将a自增至4
     * 最后此时++a取a值4
     * 得到实际为1+(4+3)的结果
     */

    a = 1;
    t = a++ * a ;
    printf("t = a ++ * a ++ = %d\n" , t ) ;

    /**
     * 1 * 2 = 2
     */

    a = 1;
    t = a * a++ ;
    printf("t = a * a++ = %d\n" , t ) ;

    /**
     * 2 * 1 = 1
     */

    a = 1;
    t = ++a * a ;
    printf("t = ++a * a = %d\n" , t ) ;

    /**
     * 2 * 2 = 4
     */

    a = 1 ;
    t = a * ++a ;
    printf("t = a * ++a = %d\n" , t ) ;

    /**
     * 2 * 2 = 4
     */

    a = 1 ;
    t = ++a * ++a ;
    printf("t = ++a * ++a = %d\n" , t ) ;

    /**
     * 3 * 3 = 9
     */

    a = 1 ;
    t = a++ + a++ * a++ ;
    printf("t = a++ + a++ * a++ = %d\n" , t ) ;

    /**
     * 1 + 2 * 3 = 7
     */

    a = 1 ;
    t = a++ + a++ * ++a ;
    printf("t = a++ + a++ * ++a = %d\n" , t ) ;

    /**
     * 1 + 2 * 4 = 9
     */

    a = 1 ;
    t = a++ + ++a * a++ ;
    printf("t = a++ + ++a * a++ = %d\n" , t ) ;

    /**
     * 1 + 4 * 3 = 13
     */

    a = 1 ;
    t = a++ + a * ++a;
    printf("t = a++ + a * ++a = %d\n" , t ) ;

    /**
     * 1 + 3 * 3 = 10
     */

    a = 1 ;
    t = a++ + a * a++;
    printf("t = a++ + a * a++ = %d\n" , t ) ;

    /**
     * 1 + 3 * 2 = 7
     */

    a = 1 ;
    t = a++ + a++ * a ;
    printf("t = a++ + a++ * a = %d\n" , t ) ;

    /**
     * 1 + 2 * 3 = 7
     */

    a = 1 ;
    t = a++ + ++a * a ;
    printf("t = a++ + ++a * a = %d\n" , t ) ; 

    /**
     * 1 + 3 * 3 = 10
     */

    /**
     * 总结：
     * 1. 从左到右的总体顺序是不会变的，后面就算有括号也不会先算，其左侧运算没处理完，就不会轮到它
     * 2. 每次以双目运算符及其两侧的表达式为一个环节，完整地处理完这个环节才进入到下一个双目运算符的环节
     * 3. 双目运算符的两个操作数可以分为三种情况：前置自增，后置自增，变量本身
     *  3.1 两个操作数如果存在一个为变量本身，则不管怎样先处理另外一个自增，然后再给将变量本身值作为最终操作数
     *  3.2 后置自增情况基本一致，都是先用运算到此时的变量值作为最终操作数，再自增
     *  3.3 前置自增则不管怎样先自增，然后处理完另一个操作数后，将最后的变量值作为最终操作数
     * 4. 因此可以将这种自增运算表达式问题分成两个问题：
     *  4.1 什么时候自增
     *  4.2 什么时候取值
     */

    return 0;
}